[
  "1. Classes \nUNIT -2 Part 1 \nBasic Structural Modelling \nClasses are the most important building block of any object-oriented system. A class is a \ndescription of a set of objects that share the same attributes, operations, relationships, and \nsemantics. A class implements one or more interfaces. \nYou use classes to capture the vocabulary of the system you are developing. These classes \nmay include abstractions that are part of the problem domain, as well as classes that make \nup an implementation. \nYou can use classes to represent software things, hardware things, and even things that are \npurely conceptual. \n \nGraphically, a class is rendered as a rectangle. \nFigure : Classes \n \nNames \nA class name must be unique within its enclosing package. Every class must have a name \nthat distinguishes it from other classes. A name is a textual string. That name alone is \nknown as a simple name; a path name is the class name prefixed by the name of the",
  "that distinguishes it from other classes. A name is a textual string. That name alone is \nknown as a simple name; a path name is the class name prefixed by the name of the \npackage in which that class lives. A class may be drawn showing only its name, as Figure  \nshows. \n \nFigure : Simple and Path Names \nAttributes \nAttributes are related to the semantics of aggregation. An attribute is a named property of \na class that describes a range of values that instances of the property may hold. A class may \nhave any number of attributes or no attributes at all. An attribute represents some property \nof the thing you are modeling that is shared by all objects of that class. \nFor example, every wall has a height, width, and thickness; you might model your \ncustomers in such a way that each has a name, address, phone number, and date of birth. \nAn attribute is therefore an abstraction of the kind of data or state an object of the class",
  "customers in such a way that each has a name, address, phone number, and date of birth. \nAn attribute is therefore an abstraction of the kind of data or state an object of the class \nmight encompass. At a given moment, an object of a class will have specific values for \nevery one of its class's attributes. \nGraphically, attributes are listed in a compartment just below the class name. Attributes \nmay be drawn showing only their names, as shown in Figure . \n \n \nFigure : Attributes \nYou can further specify an attribute by stating its class and possibly a default initial value, as \nshown Figure  \nFigure :Attributes and Their Class \nOperations \nAn operation is the implementation of a service that can be requested from any object of \nthe class to affect behavior. In other words, an operation is an abstraction of something you \ncan do to an object and that is shared by all objects of that class. A class may have any",
  "the class to affect behavior. In other words, an operation is an abstraction of something you \ncan do to an object and that is shared by all objects of that class. A class may have any \nnumber of operations or no operations at all. For example, in a windowing library such as \nthe one found in Java's awt package, all objects of the class Rectangle can be moved, \nresized, or queried for their properties. Often (but not always), invoking an operation on an \nobject changes the object's data or state. Graphically, operations are listed in a \ncompartment just below the class attributes. Operations may be drawn showing only their \nnames, as in Figure . \nFigure : Operations \n \nOrganizing Attributes and Operations \nWhen drawing a class, you don't have to show every attribute and every operation at once. \nIn fact, in most cases, you can't (there are too many of them to put in one figure) and you \nprobably shouldn't (only a subset of these attributes and operations are likely to be relevant",
  "In fact, in most cases, you can't (there are too many of them to put in one figure) and you \nprobably shouldn't (only a subset of these attributes and operations are likely to be relevant \nto a specific view). For these reasons, you can elide a class, meaning that you can choose to \nshow only some or none of a class's attributes and operations. An empty compartment \ndoesn't necessarily mean there are no attributes or operations, just that you didn't choose to \nshow them. You can explicitly specify that there are more attributes or properties than \nshown by ending each list with an ellipsis (\"...\"). \n \nTo better organize long lists of attributes and operations, you can also prefix each group \nwith a descriptive category by using stereotypes, as shown in Figure . \n \n \nFigure : Stereotypes for Class Features \nResponsibilities \nResponsibilities are an example of a defined stereotype. A responsibility is a contract or an",
  "Figure : Stereotypes for Class Features \nResponsibilities \nResponsibilities are an example of a defined stereotype. A responsibility is a contract or an \nobligation of a class. When you create a class, you are making a statement that all objects \nof that class have the same kind of state and the same kind of behavior. At a more abstract \nlevel, these corresponding attributes and operations are just the features by which the \nclass's responsibilities are carried out. A Wall class is responsible for knowing about \nheight, width, and thickness Graphically, responsibilities can be drawn in a separate \ncompartment at the bottom of the class icon, as shown in Figure . \nFigure : Responsibilities \nResponsibilities are just free-form text. In practice, a single responsibility is written as a \nphrase, a sentence, or (at most) a short paragraph. \n \n2. Relationships \n \nFigure : Relationships \nA relationship is a connection among things. In object-oriented modeling, there are three",
  "phrase, a sentence, or (at most) a short paragraph. \n \n2. Relationships \n \nFigure : Relationships \nA relationship is a connection among things. In object-oriented modeling, there are three \nkinds of relationships that are especially important: dependencies, which represent using \nrelationships among classes (including refinement, trace, and bind relationships); \ngeneralizations, which link generalized classes to their specializations; and associations, \nwhich represent structural relationships among objects. \nDependency \nA dependency is a using relationship that states that a change in specification of one thing \n(for example, class Event) may affect another thing that uses it (for example, class \nWindow), \n \n \nbut not necessarily the reverse. Graphically, a dependency is rendered as a dashed directed \nline, directed to the thing being depended on. Use dependencies when you want to show \none thing using another. \nFigure : Dependencies",
  "line, directed to the thing being depended on. Use dependencies when you want to show \none thing using another. \nFigure : Dependencies \n \nA dependency can have a name, although names are rarely needed unless you have a model \nwith many dependencies and you need to refer to or distinguish among dependencies. More \ncommonly, you'll use stereotypes to distinguish different flavors of dependencies. \nGeneralization \nA generalization is a relationship between a general thing (called the superclass or \nparent)and a more specific kind of that thing (called the subclass or child). Generalization \nis sometimes called an \"is-a-kind-of\" relationship: one thing (like the class BayWindow) is-\na- kind-of a more general thing (for example, the class Window). Generalization means \nthat objects of the child may be used anywhere the parent may appear, but not the reverse. \nGraphically, generalization is rendered as a solid directed line with a large open arrowhead,",
  "that objects of the child may be used anywhere the parent may appear, but not the reverse. \nGraphically, generalization is rendered as a solid directed line with a large open arrowhead, \npointing to the parent, as shown in Figure. Use generalizations when you want to show \nparent/child relationships. \nFigure: Generalization \n \nA class may have zero, one, or more parents. A class that has no parents and one or more \nchildren is called a root class or a base class. A class that has no children is called a leaf \nclass. A class that has exactly one parent is said to use single inheritance; a class with more \nthan one parent is said to use multiple inheritance. \nAssociation \nAn association is a structural relationship that specifies that objects of one thing are \nconnected to objects of another. Given an association connecting two classes, you can \nnavigate from an object of one class to an object of the other class, and vice versa. It's quite",
  "connected to objects of another. Given an association connecting two classes, you can \nnavigate from an object of one class to an object of the other class, and vice versa. It's quite \nlegal to have both ends of an association circle back to the same class. This means that, \ngiven an object of the class, you can link to other objects of the same class. An association \nthat connects exactly two classes is called a binary association. Although it's not as \ncommon, you can have associations that connect more than two classes; these are called   \nn-ary association. Graphically, an Association is rendered as a solid line connecting the \nsame or different classes .\n \n \nUse associations when you want to show structural relationships. \n \nBeyond this basic form, there are four adornments that apply to associations. \nName \nAn association can have a name, and you use that name to describe the nature of the",
  "Beyond this basic form, there are four adornments that apply to associations. \nName \nAn association can have a name, and you use that name to describe the nature of the \nrelationship. So that there is no ambiguity about its meaning, you can give a direction to the \nname by providing a direction triangle that points in the direction you intend to read the \nname, as shown in Figure  \nFigure: Association Names \n \nRole \nWhen a class participates in an association, it has a specific role that it plays in that \nrelationship; a role is just the face the class at the near end of the association presents to the \nclass at the other end of the association. You can explicitly name the role a class plays in an \nassociation. In Figure, a Person playing the role of employee is associated with a Company \nplaying the role of employer. \nFigure: Roles \n \nMultiplicity \nAn association represents a structural relationship among objects. In many modeling",
  "playing the role of employer. \nFigure: Roles \n \nMultiplicity \nAn association represents a structural relationship among objects. In many modeling \nsituations, it's important for you to state how many objects may be connected across an \ninstance of an association. This \"how many\" is called the multiplicity of an association's \nrole, and is written as an expression that evaluates to a range of values or an explicit value \nas in Figure 5-6. When you state a multiplicity at one end of an association, you are \nspecifying that, for each object of the class at the opposite end, there must be that many \nobjects at the near end. You can show a multiplicity of exactly one (1), zero or one (0..1), \nmany (0..*), or one or more (1..*). You can even state an exact number (for example, 3). \nFigure : Multiplicity \n \nYou can specify more complex multiplicities by using a list, such as 0..1, 3..4, 6..*, which \nwould mean \"any number of objects other than 2 or 5.\" \n \n \nAggregation",
  "Figure : Multiplicity \n \nYou can specify more complex multiplicities by using a list, such as 0..1, 3..4, 6..*, which \nwould mean \"any number of objects other than 2 or 5.\" \n \n \nAggregation \nA plain association between two classes represents a structural relationship between peers, \nmeaning that both classes are conceptually at the same level, no one more important than \nthe other. Sometimes, you will want to model a \"whole/part\" relationship, in which one \nclass represents a larger thing (the \"whole\"), which consists of smaller things (the \"parts\"). \nThis kind of relationship is called aggregation, which represents a \"has-a\" relationship, \nmeaning that an object of the whole has objects of the part. Aggregation is really just a \nspecial kind of association and is specified by adorning a plain association with an open \ndiamond at the whole end, as shown in Figure. \nFigure : Aggregation \n \n \nThe meaning of this simple form of aggregation is entirely conceptual. The open diamond",
  "diamond at the whole end, as shown in Figure. \nFigure : Aggregation \n \n \nThe meaning of this simple form of aggregation is entirely conceptual. The open diamond \ndistinguishes the \"whole\" from the \"part,\" no more, no less. This means that simple \naggregation does not change the meaning of navigation across the association between the \nwhole and its parts, nor does it link the lifetimes of the whole and its parts. \n \n3. Common Mechanisms \nThe UML is made simpler by the presence of four common mechanisms that apply \nconsistently throughout the language:  \n Specifications \n Adornments \n Common divisions \n Extensibility mechanisms \n \nSpecifications \nThe UML is more than just a graphical language. Rather, behind every part of its graphical \nnotation there is a specification that provides a textual statement of the syntax and \nsemantics of that building block. For example, behind a class icon is a specification that",
  "notation there is a specification that provides a textual statement of the syntax and \nsemantics of that building block. For example, behind a class icon is a specification that \nprovides the full set of attributes, operations (including their full signatures), and behaviors \nthat the class embodies; \nAdornments \nNotes are the most important kind of adornment that stands alone. A note is a graphical \nsymbol for rendering constraints or comments attached to an element or a collection of \nelements. \n \nMost elements in the UML have a unique and direct graphical notation that provides a \nvisual representation of the most important aspects of the element. A class's specification \nmay include other details, such as whether it is abstract or the visibility of its attributes and \noperations. Many of these details can be rendered as graphical or textual adornments to the \nclass's basic rectangular notation.",
  "operations. Many of these details can be rendered as graphical or textual adornments to the \nclass's basic rectangular notation. \n \n \n \n \nFor example, Figure shows a class, adorned to indicate that it is an abstract class with two \npublic, one protected, and one private operation. Every element in the UML's notation \nstarts with a basic symbol, to which can be added a variety of adornments specific to that \nsymbol. \nCommon Divisions \nIn modeling object-oriented systems, the world often gets divided in at least a couple of \nways. \n1. class and object \n2. interface and implementation \nExtensibility Mechanisms \nThe UML's extensibility mechanisms permit you to extend the language in controlled \nways. \nThe UML provides a standard language for writing software blueprints, but it is not \npossible for one closed language to ever be sufficient to express all possible nuances of all \nmodels across all domains across all time. The UML's extensibility mechanisms include \n1. Stereotypes",
  "possible for one closed language to ever be sufficient to express all possible nuances of all \nmodels across all domains across all time. The UML's extensibility mechanisms include \n1. Stereotypes \n2. Tagged values \n3. Constraints \n \n1. Stereotypes \nA stereotype extends the vocabulary of the UML, allowing you to create new kinds of \nbuilding blocks that are derived from existing ones but that are specific to your problem. \nFor example, if you are working in a programming language, such as Java or C++, you will \noften want to model exceptions. In these languages, exceptions are just classes, You can \nmake exceptions first class citizens in your models, meaning that they are treated like basic \nbuilding blocks, by marking them with an appropriate stereotype, as for the class Overflow \nin Figure. \n \n \n2. Tagged values \nA tagged value extends the properties of a UML building block, allowing you to create new",
  "in Figure. \n \n \n2. Tagged values \nA tagged value extends the properties of a UML building block, allowing you to create new \ninformation in that element's specification. For example, if you want to specify the version \nand author of certain critical abstractions. Version and author are not primitive UML \nconcepts. For example, the class EventQueue is extended by marking its version and author \nexplicitly. \n \n \n \n \n3. Constraints \nA constraint extends the semantics of a UML building block, allowing you to add new \nrules or modify existing ones. For example, you mght want to constrain the EventQueue \nclass so that all additions are done in order. As Figure above, you can add a constraint that \n \n  \n \n \nexplicitly marks these for the operation add. \nFigure \n:Stereotypes, \nTagged \nValues, \nand \nConstraints\n \n \n \n \nFigure: Stereotypes \nFigure :Tagged Values \nFigure : Constraint \n \n \n \n \n5. Class Diagrams",
  "Figure \n:Stereotypes, \nTagged \nValues, \nand \nConstraints\n \n \n \n \nFigure: Stereotypes \nFigure :Tagged Values \nFigure : Constraint \n \n \n \n \n5. Class Diagrams \nClass diagrams are the most common diagram found in modeling object- oriented systems. \nA class diagram shows a set of classes, interfaces, and collaborations and their \nrelationships. You use class diagrams to model the static design view of a system. For the \nmost part, this involves modeling the vocabulary of the system, modeling collaborations, or \nmodeling schemas. \nClass diagrams are also the foundation for a couple of related diagrams: component \ndiagrams and deployment diagrams. \nTerms and Concepts \nA class diagram is a diagram that shows a set of classes, interfaces, and collaborations and \ntheir relationships. Graphically, a class diagram is a collection of vertices and arcs. \nContents \nClass diagrams commonly contain the following things: \n· Classes \n· Interfaces \n· Collaborations",
  "their relationships. Graphically, a class diagram is a collection of vertices and arcs. \nContents \nClass diagrams commonly contain the following things: \n· Classes \n· Interfaces \n· Collaborations \n· Dependency, generalization, and association relationships \n \nWith the UML, you use class diagrams to visualize the static aspects of these building \nblocks and their relationships and to specify their details for construction, as you can see in \nFigure . \nFigure : Class Diagram \n \n \n \nCommon Uses \nYou use class diagrams to model the static design view of a system. This view primarily \nsupports the functional requirements of a system• the services the system should provide to its \nend users. \nWhen you model the static design view of a system, you'll typically use class diagrams in \none of three ways. \n1. To model the vocabulary of a system \nModeling the vocabulary of a system involves making a decision about which abstractions",
  "one of three ways. \n1. To model the vocabulary of a system \nModeling the vocabulary of a system involves making a decision about which abstractions \nare a part of the system under consideration and which fall outside its boundaries. You use \nclass diagrams to specify these abstractions and their responsibilities. \n2. To model simple collaborations \nA collaboration is a society of classes, interfaces, and other elements that work together to \nprovide some cooperative behavior that's bigger than the sum of all the elements. For \nexample, when you're modeling the semantics of a transaction in a distributed system, you \ncan't just stare at a single class to understand what's going on. Rather, these semantics are \ncarried out by a set of classes that work together. You use class diagrams to visualize and \nspecify this set of classes and their relationships. \n3. To model a logical database schema \nThink of a schema as the blueprint for the conceptual design of a database. In many",
  "specify this set of classes and their relationships. \n3. To model a logical database schema \nThink of a schema as the blueprint for the conceptual design of a database. In many \ndomains, you'll want to store persistent information in a relational database or in an object- \noriented database. You can model schemas for these databases using class diagrams. \n \nCommon \nModelingTechniques  \n1. \nModelingSimpleCollaboration \n \nNo class stands alone. Rather, each works in collaboration with others to carry out some \nsemantics greater than each individual. Therefore, in addition to capturing the vocabulary \nof your system, you'll also need to turn your attention to visualizing, specifying, \nconstructing, and documenting the various ways these things in your vocabulary work \ntogether. You use class diagrams to represent such collaborations. \nTo model a collaboration, \n Identify the mechanism you'd like to model. A mechanism represents some function or",
  "together. You use class diagrams to represent such collaborations. \nTo model a collaboration, \n Identify the mechanism you'd like to model. A mechanism represents some function or \nbehavior of the part of the system you are modeling that results from the interaction of a \nsociety of classes, interfaces, and other things. \n For each mechanism, identify the classes, interfaces, and other collaborations that \nparticipate in this collaboration. Identify the relationships among these things, as well. \n Use scenarios to walk through these things. Along the way, you'll discover parts of your \nmodel that were missing and parts that were just plain semantically wrong. \n Be sure to populate these elements with their contents. For classes, start with getting a good \nbalance of responsibilities. Then, over time, turn these into concrete attributes and \noperations. \nThe figure focuses on the classes involved in the mechanism for moving the robot along a",
  "balance of responsibilities. Then, over time, turn these into concrete attributes and \noperations. \nThe figure focuses on the classes involved in the mechanism for moving the robot along a \npath. You'll find one abstract class (Motor) with two concrete children, Steering Motor and \nMain Motor. Both of these classes inherit the five operations of their parent, Motor. \n \n \n \n \n \n2. Modeling a Logical Database Schema \n \nMany of the systems you'll model will have persistent objects, which means that they can \nbe stored in a database for later retrieval. Most often, you'll use a relational database, an \nobject oriented database, or a hybrid object/relational database for persistent storage. The \nUML is well suited to modeling logical database schemas, as well as physical databases \nthemselves. \nThe UML's class diagrams are a superset of entity-relationship (E-R) diagrams, a common \nmodeling tool for logical database design. Whereas classical E-R diagrams focus only on",
  "themselves. \nThe UML's class diagrams are a superset of entity-relationship (E-R) diagrams, a common \nmodeling tool for logical database design. Whereas classical E-R diagrams focus only on \ndata, class diagrams go a step further by permitting the modeling of behavior, as well. In \nthe physical database, these logical operations are generally turned into triggers or stored \nprocedures. \nTo model a schema, \n Identify those classes in your model whose state must transcend the lifetime of their \napplications. \n Create a class diagram that contains these classes and mark them as persistent (a standard \ntagged value). You can define your own set of tagged values to address database-specific \ndetails. \n Expand the structural details of these classes. In general, this means specifying the details \nof their attributes and focusing on the associations and their cardinalities that structure \nthese classes. \n Watch for common patterns that complicate physical database design, such as cyclic",
  "of their attributes and focusing on the associations and their cardinalities that structure \nthese classes. \n Watch for common patterns that complicate physical database design, such as cyclic \nassociations, one-to-one associations, and n-ary associations. Where necessary, create \nintermediate abstractions to simplify your logical structure. \n Consider also the behavior of these classes by expanding operations that are important for \ndata access and data integrity. In general, to provide a better separation of concerns, \nbusiness rules concerned with the manipulation of sets of these objects should be \nencapsulated in a layer above these persistent classes. \n Where possible, use tools to help you transform your logical design into a physical design. \n \n \nFigure :  Modeling a Schema \n \n3. Forward and Reverse Engineering \nModeling is important, but you have to remember that the primary product of a",
  "Figure :  Modeling a Schema \n \n3. Forward and Reverse Engineering \nModeling is important, but you have to remember that the primary product of a \ndevelopment team is software, not diagrams. Of course, the reason you create models is to \npredictably deliver at the right time the right software that satisfies the evolving goals of its \nusers and the business. For this reason, it's important that the models you create and the \nimplementations you deploy map to one another and do so in a way that minimizes or even \neliminates the cost of keeping your models and your implementation in sync with one \nanother. \nForward engineering is the process of transforming a model into code through a mapping \nto an implementation language. Forward engineering results in a loss of information, \nbecause models written in the UML are semantically richer than any current object-\noriented programming language. In fact, this is a major reason why you need models in",
  "because models written in the UML are semantically richer than any current object-\noriented programming language. In fact, this is a major reason why you need models in \naddition to code. Structural features, such as collaborations, and behavioral features, such \nas interactions, can be visualized clearly in the UML, but not so clearly from raw code. \nTo forward engineer a class diagram, \n Identify the rules for mapping to your implementation language or languages of choice. \nThis is something you'll want to do for your project or your organization as a whole. \n Depending on the semantics of the languages you choose, you may have to constrain your \nuse of certain UML features. For example, the UML permits you to model multiple \ninheritance, but Smalltalk permits only single inheritance. You can either choose to \nprohibit developers from modeling with multiple inheritance (which makes your models \nlanguage- dependent) or develop idioms that transform these richer features into the",
  "prohibit developers from modeling with multiple inheritance (which makes your models \nlanguage- dependent) or develop idioms that transform these richer features into the \nimplementation language (which makes the mapping more complex). \n Use tagged values to specify your target language. You can do this at the level of \nindividual classes if you need precise control. You can also do so at a higher level, such as \nwith collaborations or packages. \n Use tools to forward engineer your models. \n \n \nFigure - Forward Engineering \n \n \nReverse engineering is the process of transforming code into a model through a mapping \nfrom a specific implementation language. Reverse engineering results in a flood of \ninformation, some of which is at a lower level of detail than you'll need to build useful \nmodels. At the same time, reverse engineering is incomplete. There is a loss of information \nwhen forward engineering models into code, and so you can't completely recreate a model",
  "models. At the same time, reverse engineering is incomplete. There is a loss of information \nwhen forward engineering models into code, and so you can't completely recreate a model \nfrom code unless your tools encode information in the source comments that goes beyond \nthe semantics of the implementation language. \nTo reverse engineer a class diagram, \n \n Identify the rules for mapping from your implementation language or languages of choice. \nThis is something you'll want to do for your project or your organization as a whole. \n Using a tool, point to the code you'd like to reverse engineer. Use your tool to generate a \nnew model or modify an existing one that was previously forward engineered. \n Using your tool, create a class diagram by querying the model. For example, you might \nstart with one or more classes, then expand the diagram by following specific relationships \nor other neighboring classes. Expose or hide details of the contents of this class diagram as",
  "start with one or more classes, then expand the diagram by following specific relationships \nor other neighboring classes. Expose or hide details of the contents of this class diagram as \nnecessary to communicate your intent. \n \n6. Object Diagrams \nObject diagrams model the instances of things contained in class diagrams. An object \ndiagram shows a set of objects and their relationships at a point in time. \nYou use object diagrams to model the static design view or static process view of a system. \nThis involves modeling a snapshot of the system at a moment in time and rendering a set of \nobjects, their state, and their relationships. \n \nAn object diagram, therefore, expresses the static part of an interaction, consisting of the \nobjects that collaborate,  but without any of the messages passed among them. In both \ncases, an object diagram freezes a moment in time, as in Figure  \n \n \nFigure  An Object Diagram \n \nTerms and Concepts",
  "cases, an object diagram freezes a moment in time, as in Figure  \n \n \nFigure  An Object Diagram \n \nTerms and Concepts \nAn object diagram is a diagram that shows a set of objects and their relationships at a point \nin time. Graphically, an object diagram is a collection of vertices and arcs \nContents \nObject diagrams commonly contain \n Objects \n Links \n \n \nCommon Uses \nYou use object diagrams to model the static design view or static process view of a system \njust as you do with class diagrams, but from the perspective of real or prototypical \ninstances. This view primarily supports the functional requirements of a system• that is, the \nservices the system should provide to its end users. Object diagrams let you model static \ndata structures. \nWhen you model the static design view or static process view of a system, you typically \nuse object diagrams in one way: \n· To model object structures \n \nCommonModeling \nTechniques  \n1.  \nModeling Object Structures",
  "use object diagrams in one way: \n· To model object structures \n \nCommonModeling \nTechniques  \n1.  \nModeling Object Structures \nWhen you construct a class diagram, a component diagram, or a deployment diagram, what \nyou are really doing is capturing a set of abstractions that are interesting to you as a group \nand, in that context, exposing their semantics and their relationships to other abstractions  \nin the group. \nTo model an object structure, \n Identify the mechanism you'd like to model. A mechanism represents some function or \nbehavior of the part of the system you are modeling that results from the interaction of a \n \n \nsociety of classes, interfaces, and other things. \n \n For each mechanism, identify the classes, interfaces, and other elements that participate in \nthis collaboration; identify the relationships among these things, as well. \n Consider one scenario that walks through this mechanism. Freeze that scenario at a",
  "this collaboration; identify the relationships among these things, as well. \n Consider one scenario that walks through this mechanism. Freeze that scenario at a \nmoment in time, and render each object that participates in the mechanism. \n Expose the state and attribute values of each such object, as necessary, to understand the \nscenario. \n Similarly, expose the links among these objects, representing instances of associations \namong them. \n \nFor example, Figure shows a set of objects drawn from the implementation of an \nautonomous robot. This figure focuses on some of the objects involved in the mechanism \nused by the robot to calculate a model of the world in which it moves. \n \n \n \n \nFigure 14-2 Modeling Object Structures \n2.Forward and Reverse Engineering \n \n \nForward engineering (the creation of code from a model) an object diagram is theoretically \npossible but pragmatically of limited value. In an object-oriented system, instances are",
  "Forward engineering (the creation of code from a model) an object diagram is theoretically \npossible but pragmatically of limited value. In an object-oriented system, instances are \nthings that are created and destroyed by the application during run time. Therefore, you \ncan't exactly instantiate these objects from the outside. \n \n \nTo reverse engineer an object diagram, \n Chose the target you want to reverse engineer. Typically, you'll set your context inside an \noperation or relative to an instance of one particular class. \n Using a tool or simply walking through a scenario, stop execution at a certain moment in \ntime. \n Identify the set of interesting objects that collaborate in that context and render them in an \nobject diagram. \n As necessary to understand their semantics, expose these object's states. \n As necessary to understand their semantics, identify the links that exist among these \nobjects.",
  "object diagram. \n As necessary to understand their semantics, expose these object's states. \n As necessary to understand their semantics, identify the links that exist among these \nobjects. \n If your diagram ends up overly complicated, prune it by eliminating objects that are not \ngermane to the questions about the scenario you need answered. If your diagram is too \nsimplistic, expand the neighbors of certain interesting objects and expose each object's state \nmore deeply. \n \n \n7. Interaction Diagrams \nSequence diagrams and collaboration diagrams \n both of which are called interaction diagrams \n are two of the five diagrams used in the UML for modeling the dynamic aspects of \nsystems.  \nAn interaction diagram shows an interaction, consisting of a set of objects and their \nrelationships, including the messages that may be dispatched among them. A sequence \ndiagram is an interaction diagram that emphasizes the time ordering of messages; a",
  "relationships, including the messages that may be dispatched among them. A sequence \ndiagram is an interaction diagram that emphasizes the time ordering of messages; a \ncollaboration diagram is an interaction diagram that emphasizes the structural organization \nof the objects that send and receive messages. \n \n \nTerms and Concepts \nAn interaction diagram shows an interaction, consisting of a set of objects and their \nrelationships, including the messages that may be dispatched among them. A sequence \ndiagram is an interaction diagram that emphasizes the time ordering of messages. \nGraphically, a sequence diagram is a table that shows objects arranged along the X axis and \nmessages, ordered in increasing time, along the Y axis. A collaboration diagram is an \ninteraction diagram that emphasizes the structural organization of the objects that send and \nreceive messages. Graphically, a collaboration diagram is a collection of vertices and arcs. \n \n \nContents",
  "receive messages. Graphically, a collaboration diagram is a collection of vertices and arcs. \n \n \nContents \nInteraction diagrams commonly contain \n Objects \n Links \n Message\n \n \nA. \nSequence Diagrams \nA sequence diagram emphasizes the time ordering of messages. As Figure  shows, you \nform a sequence diagram by first placing the objects that participate in the interaction at the \ntop of your diagram, across the X axis. Typically, you place the object that initiates the \ninteraction at the left, and increasingly more subordinate objects to the right. Next, you \nplace the messages that these objects send and receive along the Y axis, in order of \nincreasing time from top to bottom. This gives the reader a clear visual cue to the flow of \ncontrol over time. \nFigure  Sequence Diagram \n \nSequence diagrams have two features that distinguish them from collaboration diagrams. \n \nYou can specify the vitality of an object or a link by marking it with a new destroyed, or \ntransient constraint",
  "You can specify the vitality of an object or a link by marking it with a new destroyed, or \ntransient constraint \nFirst, there is the object lifeline. An object lifeline is the vertical dashed line that \nrepresents the existence of an object over a period of time. \nSecond, there is the focus of control. The focus of control is a tall, thin rectangle that \nshows the period of time during which an object is performing an action, either directly or \nthrough a subordinate procedure \n \n \n \nB. \nCollaboration Diagrams \nA collaboration diagram emphasizes the organization of the objects that participate in an \ninteraction. \nCollaboration diagrams have two features that distinguish them from sequence diagrams. \nFirst, there is the path. To indicate how one object is linked to another, you can attach a \npath stereotype to the far end of a link (such as »localᑺ, indicating that the designated \nobject is local to the sender).",
  "path stereotype to the far end of a link (such as »localᑺ, indicating that the designated \nobject is local to the sender). \nSecond, there is the sequence number. To indicate the time order of a message, you prefix \nthe message with a number (starting with the message numbered 1), increasing \nmonotonically for each new message in the flow of control (2, 3, and so on). To show \nnesting, you use Dewey decimal numbering (1 is the first message; 1.1 is the first message \nnested in message 1; 1.2 is the second message nested in message 1; and so on). You can \nshow nesting to an arbitrary depth. Note also that, along the same link, you can show many \nmessages (possibly being sent from different directions), and each will have a unique \nsequence number. \n \nAs Figure shows, you form a collaboration diagram by first placing the objects that \nparticipate in the interaction as the vertices in a graph. Next, you render the links that",
  "sequence number. \n \nAs Figure shows, you form a collaboration diagram by first placing the objects that \nparticipate in the interaction as the vertices in a graph. Next, you render the links that \nconnect these objects as the arcs of this graph. Finally, you adorn these links with the \nmessages that objects send and receive. This gives the reader a clear visual cue to the flow \nof control in the context of the structural organization of objects that collaborate. \nFigure  Collaboration Diagram \n \nSemantic Equivalence \nBecause they both derive from the same information in the UML's metamodel, sequence \ndiagrams and collaboration diagrams are semantically equivalent. As a result, you can take a \n \n \ndiagram in one form and convert it to the other without any loss of information, as you can \nsee in the previous two figures, which are semantically equivalent. However, this does not \nmean that both diagrams will explicitly visualize the same information. For example, in the",
  "see in the previous two figures, which are semantically equivalent. However, this does not \nmean that both diagrams will explicitly visualize the same information. For example, in the \nprevious two figures, the collaboration diagram shows how the objects are linked (note the \n»localᑺ and »globalᑺ stereotypes), whereas the corresponding sequence diagram does not. \nSimilarly, the sequence diagram shows message return (note the return value committed), \nbut the corresponding collaboration diagram does not. In both cases, the two diagrams \nshare the same underlying model, but each may render some things the other does not. \n \nCommon Uses \nYou use interaction diagrams to model the dynamic aspects of a system. These dynamic \naspects may involve the interaction of any kind of instance in any view of a system's \narchitecture, including instances of classes (including active classes), interfaces, \ncomponents, and nodes.",
  "aspects may involve the interaction of any kind of instance in any view of a system's \narchitecture, including instances of classes (including active classes), interfaces, \ncomponents, and nodes. \nWhen you model the dynamic aspects of a system, you typically use interaction diagrams \nin two ways. \n1. To model flows of control by time ordering \nHere you'll use sequence diagrams. Modeling a flow of control by time ordering \nemphasizes the passing of messages as they unfold over time, which is a particularly useful \nway to visualize dynamic behaviour in the context of a use case scenario. Sequence \ndiagrams do a better job of visualizing simple iteration and branching than do collaboration \ndiagrams. \n2. To model flows of control by organization \nHere you'll use collaboration diagrams. Modeling a flow of control by organization \nemphasizes the structural relationships among the instances in the interaction, along which",
  "Here you'll use collaboration diagrams. Modeling a flow of control by organization \nemphasizes the structural relationships among the instances in the interaction, along which \nmessages may be passed. Collaboration diagrams do a better job of visualizing complex \niteration and branching and of visualizing multiple concurrent flows of control than do \nsequence diagrams. \n \nCommon Modeling Techniques \n \n1. Modeling Flows of Control by Time Ordering \nConsider the objects that live in the context of a system, subsystem, operation or class. \nConsider also the objects and roles that participate in a use case or collaboration. To model \na flow of control that winds through these objects and roles, you use an interaction \ndiagram; to emphasize the passing of messages as they unfold over time, you use a \nsequence diagram, a kind of interaction diagram. \nTo model a flow of control by time ordering,",
  "diagram; to emphasize the passing of messages as they unfold over time, you use a \nsequence diagram, a kind of interaction diagram. \nTo model a flow of control by time ordering, \n Set the context for the interaction, whether it is a system, subsystem, operation, or class, or \none scenario of a use case or collaboration. \n Set the stage for the interaction by identifying which objects play a role in the interaction. \nLay them out on the sequence diagram from left to right, placing the more important \nobjects to the left and their neighboring objects to the right. \n Set the lifeline for each object. In most cases, objects will persist through the entire \ninteraction. For those objects that are created and destroyed during the interaction, set their \nlifelines, as appropriate, and explicitly indicate their birth and death with appropriately \nstereotyped messages. \n \n \n Starting with the message that initiates this interaction, lay out each subsequent message",
  "stereotyped messages. \n \n \n Starting with the message that initiates this interaction, lay out each subsequent message \nfrom top to bottom between the lifelines, showing each message's properties (such as its \nparameters), as necessary to explain the semantics of the interaction. \n If you need to visualize the nesting of messages or the points in time when actual \ncomputation is taking place, adorn each object's lifeline with its focus of control. \n If you need to specify time or space constraints, adorn each message with a timing mark \nand attach suitable time or space constraints. \n If you need to specify this flow of control more formally, attach pre- and postconditions to \neach message. \n \n2. Modeling Flows of Control by Organization \nConsider the objects that live in the context of a system, subsystem, operation, or class. \nConsider also the objects and roles that participate in a use case or collaboration. To model",
  "Consider the objects that live in the context of a system, subsystem, operation, or class. \nConsider also the objects and roles that participate in a use case or collaboration. To model \na flow of control that winds through these objects and roles, you use an interaction \ndiagram; to show the passing of messages in the context of that structure, you use a \ncollaboration diagram, a kind of interaction diagram. \nTo model a flow of control by organization, \n Set the context for the interaction, whether it is a system, subsystem, operation, or class, or \none scenario of a use case or collaboration. \n Set the stage for the interaction by identifying which objects play a role in the interaction. \nLay them out on the collaboration diagram as vertices in a graph, placing the more \nimportant objects in the center of the diagram and their neighboring objects to the outside. \n Set the initial properties of each of these objects. If the attribute values, tagged values,",
  "important objects in the center of the diagram and their neighboring objects to the outside. \n Set the initial properties of each of these objects. If the attribute values, tagged values, \nstate, or role of any object changes in significant ways over the duration of the interaction, \nplace a duplicate object on the diagram, update it with these new values, and connect them \nby a message stereotyped as become or copy (with a suitable sequence number). \n Specify the links among these objects, along which messages may pass. \n1. Lay out the association links first; these are the most important ones, because they \nrepresent structural connections. \n2. Lay out other links next, and adorn them with suitable path stereotypes (such as \nglobal and local) to explicitly specify how these objects are related to one another. \n Starting with the message that initiates this interaction, attach each subsequent message to",
  "global and local) to explicitly specify how these objects are related to one another. \n Starting with the message that initiates this interaction, attach each subsequent message to \nthe appropriate link, setting its sequence number, as appropriate. Show nesting by using \nDewey decimal numbering. \n If you need to specify time or space constraints, adorn each message with a timing mark \nand attach suitable time or space constraints. \n If you need to specify this flow of control more formally, attach pre- and postconditions to \neach message. \n \n3. Forward and Reverse Engineering \nForward engineering (the creation of code from a model) is possible for both sequence and \ncollaboration diagrams, especially if the context of the diagram is an operation \n  \nReverse engineering (the creation of a model from code) is also possible for both sequence \nand collaboration diagrams, especially if the context of the code is the body of an",
  "Reverse engineering (the creation of a model from code) is also possible for both sequence \nand collaboration diagrams, especially if the context of the code is the body of an \noperation. Segments of the previous diagram could have been produced by a tool from a \nprototypical execution of the register operation. \n \nForward engineering is straightforward; reverse engineering is hard."
]